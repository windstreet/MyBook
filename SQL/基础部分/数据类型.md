# 数据类型

### 一、数值类型

| 数值类型 | 类型名称 | 存储空间 | 数据范围 | 说明 |
| :----- | :----- | :-----  | :----- | :----- |
| 整数类型 | SMALLINT | 2字节 | -32 768~32 767 | 小范围整型 |
| 整数 | INT(INTEGER) | 4字节 | －2 147 483 648〜2 147 483 647 | 普通整型 |
| 整数 | BIGINT | 8字节 | -9 223 372 036 854 775 808 〜 9 223 372 036 854 775 807 | 大整型 |
| 浮点数类型 | REAL | 4字节 | 6 位十进制数字精度 | 浮点数类型 |
| 浮点数 | DOUBLE PRECISION | 8字节 | 15 位十进制数字精度 | 双精度浮点数类型 |
| 任意精度类型 | NUMERIC | 变长 | 任意 | 任意精度类型 |
| 序号类型 | SERIAL | 4字节 | 1 ~ +2 147 483 647 | 自增整数 |
| 序号 | BIGSERIAL | 8字节 | 1 ~ +9 223 372 036 854 775 807 | 大范围的自增整数 |

1. 整数类型
    - 三者在存储空间和数据范围上有所不同。    
    - 存储空间越小查询效率越高。

2. 浮点数类型
    - 浮点数表示小数。
    - PostgreSQL也支持使用标准的SQL语法，即：float和float(p)来声明非精确的数值类型，p表示可接受的精度。
    - REAL类型对应float(1)~float(24)，DOUBLE PRECISION对应float(25)~float(53)，未声明精度时将被当作DOUBLE PRECISION处理。

3. 任意精度类型
    - PostgreSQL中任意精度类型可存储最多1000位精度的数字并且准确地进行计算。
    - 非常适合用于货币金额和其它要求计算准确的数据。
    - 但是，NUMERIC类型的运算速度要比整数类型或者浮点数类型要慢很多。
    - 使用格式为：NUMERIC(M,N)。其中，M称为精度，表示总位数；N称为标度，表示小数位。M和N决定了NUMERIC的取值范围，当用户数据的精度超出指定精度时，会进行四舍五入处理。

4. 序号类型
    - 它并不是真正的类型，只是为在表中设置唯一标识做的概念上的便利。
    - ```sql
      CREATE TABLE tablename (
        colname SERIAL
      );

      -- 等价于：

      CREATE SEQUENCE tablename_colname_seq;
        CREATE TABLE tablename(
	    colname integer DEFAULT nextval('tablename_colname_seq') NOT NULL
      );
      ```
    - 类型名 SERIAL 和 SERIAL4 是等效的： 两个都创建 INTEGRE 字段。
    - 类型名 BIGSERIAL 和 SERIAL8 也一样，只不过它创建一个 BIGINT 字段。 
    - 如果你预计在表的生存期中使用的标识数目超过 231 个，那么你应该使用 BIGSERIAL。

---

### 二、日期时间类型

PostgreSQL保存日期时间格式的数据类型有多种，主要有：`TIME、DATE、TIMESTAMP、INTERVAL`。

日期时间类型输入像`字符串类型`输入一样，需要加`单引号`。

每种日期时间类型都有合法的取值范围，超出范围时系统会将“零”插入数据记录中。

| 类型名称 | 存储空间 | 数据范围 | 说明 | 分辨率 | 
| :----- | :----- | :-----  | :----- | :----- |
| TIME | 8字节 | 00:00:00 ~ 24:00:00 | 时间类型（只用于一天内的时间）［无时区］ | 1毫秒/14位 |
| TIME[with time zone] | 12字节 | 00:00:00+1359~24:00:00-1359 | 时间类型（只用于一天内的时间）［含时区］ | 1毫秒/14位 |
| DATE | 4字节 | 4713 BC~32767 AD | 只用于一天的日期 | 1天 |
| TIMESTAMP | 8字节 | 4713 BC~5874897 AD | 日期和时间［无时区］ | 1毫秒/14位 |
| TIMESTAMP[with time zone] | 8字节 | 4713 BC~5874897 AD | 日期和时间［含时区］| 1毫秒/14位 |
| INTERVAL | 12字节 | -178000000年~178000000年 | 时间间隔 | 1毫秒/14位 |


#### 2.1、时间类型
- 时间类型是TIME和TIME[with time zone]，默认情况下为不带时区（即:TIME）。
- 不带时区时间格式可接受输入方式有：`HH:MM:SS`、`HH:MM`、`HHMMSS`。
- 带时间格式输入可用系统的`NOW()`函数。
- 时间、时区输入参考如下。

##### 时间输入：
| 示例 | 描述 |
| :----- | :----- | 
| 04:05:06.789 | ISO 8601 |
| 04:05:06 | ISO 8601 |
| 04:05 | ISO 8601 |
| 040506 | ISO 8601 |
| 04:05 AM | 与 04:05 一样；AM 不影响数值 |
| 04:05 PM | 与 16:05 一样；输入小时数必须 <= 12 |
| 04:05:06.789-8 | ISO 8601 |
| 04:05:06-08:00 | ISO 8601 |
| 04:05-08:00 | ISO 8601 |
| 040506-08 | ISO 8601 |
| 04:05:06 PST | 用名字声明的时区 |

##### 时区输入：
| 示例 | 描述 |
| :----- | :----- | 
| PST | 太平洋标准时间（Pacific Standard Time） |
| -8:00 | ISO-8601 与 PST 的偏移 |
| -800 | ISO-8601 与 PST 的偏移 |
| -8 | ISO-8601 与 PST 的偏移 |
| zulu | 某军方对 UTC 的缩写 |
| z | zulu的缩写 |


#### 2.2、DATE类型
- 日期输入格式为：`YYYY-MM-DD`、`YYYYMMDD`。
- 可以使用`字符串或数字类型`的数据输入，符合DATE的日期格式即可。
- 可以使用`CURRENT_DATE`或`NOW()`插入当前系统时间。


#### 2.3、TIMESTAMP类型
- 其有效输入由日期和时间的联接组成，后面跟着一个可选的时区，一个可选的 AD 或者 BC。
- 时间戳输入格式为：`YYYY-MM-DD HH:MM:SS`。
- 带时区输入格式为：`2015-03-22 4:05:06 -8:00`。


#### 2.4、INTERVAL类型
INTERVAL类型输入格式如下：
```sql
quantity unit [quantity unit...] [direction]
```
- quantity 是一个数字或符号； 
- unit 是 second, minute, hour, day, week, month, year, decade, century, millennium, 或这些单位的缩写或复数； 
- direction 可以是 ago 或者为空。
- 符号 @ 是一个可选的东西。
- 不同的单位以及相应正确的符号都是隐含地增加。


---


### 三、字符串类型、二进制类型

PostgreSQL支持两种字符型数据：`文本字符串`和`二进制字符串`

文本字符串的类型：`char、varchar、text`

二进制字符串的类型：`bytea`

| 类型名称 | 存储空间 | 长度 |
| :----- | :----- | :----- | 
| char(n)/character | 用户定义 | 定长，有长度限制 |
| varchar(n)/character varying(n) | 用户定义 | 变长，有长度限制 |
| text | 实际长度 | 变长，无长度限制 |
| tytea | 4字节加上实际的二进制字串 | 变长，无长度限制 |


1. char和varchar类型
    - 两种类型最多存储用户自定义长度N个字符，超出长度会产生错误。
    - 存储字符小于定义长度时，CHAR类型会用空格补满存储空间，VARCHAR类型只存储实际长度。

2. text类型
    - TEXT不是标准的SQL类型，许多数据库系统都实现了这一类型，在PostgreSQL中，TEXT可存储任意长度的字符串。

3. tytea类型
    - PostgreSQL提供了BYTEA类型，用于存储二进制字符串。
    - BYTEA类型数据存储空间为用户实际二进制字符串加4字节。
    - 例如向file表file_byte字段插入E'\\001'数据，SQL语句如下：`INSERT INTO file file_byte VALUES (E'\\001);`


---

### 四、布尔类型、位串类型

支持标准的 SQL boolean 数据类型，boolean值只有两种： `'真'('True') 或 '假'('False')`。

boolean有两种值外的第三种状态，`'未知'('Unknow')`，用 SQL空状态表示。

位串就是一串 `1 和 0 的字符串`。它们可以用于存储和视觉化位掩码。


##### 4.1、布尔类型
- boolean类型存储空间为1字节，
- 可接受的"真"值的有效文本输入值有：`TRUE、't'、'true'、'y'、'yes'、'1'`。
- "假"值可接受的有效输入值有：`FALSE、'f'、'false'、'n'、'no'、'0'`。
- 建议使用与SQL标准兼容的 `TRUE和FALSE` 做为boolean类型的输入值。
- 查询时使用字母 `t 和 f` 做为boolean型数据显示。

##### 4.2、位串类型
- 有两种类型的SQL位类型：`bit(n) 和 bit varying(n)`；
- bit 类型的数据必须准确匹配长度n; 
- bit varying 类型数据是最大长度为n的变长类型；
- 把一个位串值转换成bit(n)，那么它的右边将被截断或者在右边补齐零，以符合定义的n位长度，不会抛出任何错误。
- 把一个位串数值转换成 bit varying(n)，如果它超过了n位，那么它的右边将被截断。

示例：创建包括a(bit)，b(bit varying)两列表test，插入数据后执行查询，SQL语句如下：

```sql
CREATE TABLE test (a bit(3), b bit varying(5));
INSERT INTO test VALUES (B'101', B'00');
INSERT INTO test VALUES (B'10', B'101');    
ERROR:  Bit string length 2 does not match type bit(3)
INSERT INTO test VALUES (B'10'::bit(3), B'101');
SELECT * FROM test;
```

显示结果如下：

| a | b |
| :----- | :----- | 
| 101 | 00 |
| 100 | 101 |


---

### 五、数组类型

PostgreSQL 允许将字段定义成定长或不定长的多维数组。 

数组类型可以是任何基本类型或用户定义类型（复合类型和域的数组还不支持）。


##### 5.1、数据类型定义
- 数组类型定义是通过在数组元素类型名后面加方括号：`[]` 来命名的。
- PostgreSQL目前的实现并不强制限制数组长度，即：声明长度和未声明长度的数组相同。
- 也不强制数组维数，特定元素类型的数组都被认为是相同的类型，不管他们的大小或者维数。

创建数组类型字段示例如下：
```sql
CREATE TABLE array_tmp(
    name                text,
    pay_by_quarter      integer[],
    schedule            text[][],
    squares             integer[3][3]        --指定长度后仍然不会限制长度
);
```

##### 5.2、数组类型数据插入
- 数组类型数据插入用`大括号`把值括起来并且用`逗号`将它们分开。
- 可以在任意数组值周围添加`双引号`，如果值包含逗号或者花括弧，必须加上双引号输入。
- 数据类型数据插入，还可以使用ARRAY构造器。示例如下：

```sql
INSERT INTO array_tmp VALUES(
    'itbilu', 
    '{1,2,3,4}', 
    '{{"include {"},{"2value"}}', 
    '{{111,122},{211, 222}}'
);

INSERT INTO array_tmp VALUES (
    'liuht', 
    ARRAY[1,2,3,4], 
    ARRAY[['value 11', 'value 12'], ['value 21', 'value 22']], 
    ARRAY[[111,122],[211, 222]]
);   --使用ARRAY构造器
```

查询结果如下：

```
  name  | pay_by_quarter |                     schedule                      |        squares        
--------+----------------+---------------------------------------------------+-----------------------
 itbilu | {1,2,3,4}      | {{"include {"},{2value}}                          | {{111,122},{211,222}}
 liuht  | {1,2,3,4}      | {{"value 11","value 12"},{"value 21","value 22"}} | {{111,122},{211,222}}
```

##### 5.3、数组类型数据的查询
- PostgreSQL中数组也是通过下标数字的方式进行访问，只是PostgreSQL中数组元素的下标是从1开始n结束，格式如：[n]。
- 对于一维或更多维数组，查询一个数组的部分数据查询格式为：[脚标界上:脚标下界]。

数组下标定位查询及返回结果：

```sql
liuht=# SELECT name, schedule  FROM array_tmp WHERE schedule[1][1]='value 11';


  name  |                     schedule                      
--------+---------------------------------------------------
 itbilu | {{"value 11","value 12"},{"value 21","value 22"}}
(1 row)
```

查询多维数据的部分数据，如查询单维字段pay_by_quarter的第2,3列数据，及多维列schedule的第1维的1列数据和第2维第一列数据。SQL语句及查询结果如下：
```sql
liuht=# SELECT pay_by_quarter[2:3],schedule[1:2][1:1] FROM array_tmp;


 pay_by_quarter |          schedule           
----------------+-----------------------------
 {2,3}          | {{"include {"},{2value}}
 {2,3}          | {{"value 11"},{"value 21"}}
(2 rows)
```

---


### 六、复合类型

PostgreSQL 复合类型描述一行或者一条记录的`结构`，实际上它只是一个字段名和它们的数据类型的列表。

在 PostgreSQL 中你可以像使用简单数据类型那样使用复合类型。


##### 6.1、复合类型声明
- 复合类型只能声明字段名字和类型，不能声明约束（比如 NOT NULL 这样的）。
- 使用复合类型需要先定义，之后在创建表的语句中引用定义的复合类型。

示例：

```sql
-- 定义复合类型 student_lesson
CREATE TYPE student_lesson AS (
    name            text,
    times           numeric
);
CREATE TABLE students (
    name       text,
    lesson     student_lesson  -- 使用
);
```


##### 6.2、复合类型数据插入
复合类型数据插入要`以文本常量书写复合类型值`，在圆括弧里包括字段值并且用逗号分隔，如果值本身包含逗号或者圆括弧，刚需要用双引号括起来。 

复合类型常量的一般格式如下：`'( val1 , val2 , ... )'`

例如，在上一步创建的表中插入数据：

```sql
INSERT INTO students VALUES('itbilu', '("math", 3)');
INSERT INTO students VALUES('liuht', ROW('math', 5));
-- INSERT 0 1


SELECT * FROM students;

--   name  |  lesson  
-- --------+----------
--  itbilu | (math,3)
--  liuht  | (math,5)
-- 
-- (1 row)
```


##### 6.3、复合类型查询
要访问复合类型字段的一个子字段，需要按 `字段名.子字段` 的形式查询，非常类似从一个表名字里查出一个字段。

为避免分析器混淆，需要在查询的复合类型字段外增加`圆括弧`。

示例如下：
```sql
SELECT lesson.name FROM students;
-- ERROR:  missing FROM-clause entry for table "lesson"     --不加圆括号会按表查询，查询失败
-- LINE 1: SELECT lesson.name FROM students;
--                ^


SELECT (lesson).name FROM students;               --正确的查询方法
--  name 
-- ------
--  math
--  math
-- (1 row)
```

如查在查询中需要使用表名，并按复合类型的子字段进行筛选。可参考下面的示例进行查询：

```sql
SELECT students.name, (students.lesson).name FROM students WHERE (students.lesson).times>3;

--   name  | name 
--  -------+------
--   liuht | math
--  (1 row)

```


##### 6.4、复合类型数据修改
```sql
--  方式一：整字段更新
UPDATE students SET lesson = ROW('Liuht', 6) WHERE name = 'liuht'; 
--  UPDATE 1


--  方式二：子字段更新   
UPDATE students SET lesson.times = 7 WHERE name = 'itbilu';                                                                                        
-- UPDATE 1


SELECT * FROM students;

--    name  |  lesson   
--  --------+-----------
--   liuht  | (Liuht,6)
--   itbilu | (math,7)
--  (2 rows)
```
